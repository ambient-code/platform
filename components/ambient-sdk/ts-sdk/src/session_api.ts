// Code generated by ambient-sdk-generator from openapi.yaml â€” DO NOT EDIT.
// Source: /home/mturansk/projects/src/github.com/ambient/platform/components/ambient-api-server/openapi/openapi.yaml
// Spec SHA256: 8ab1aa38f80654f4de02c1a997e1ac8d7d502606cbe5ff819abb6fdc2c7c504d
// Generated: 2026-02-15T12:36:04Z

import type { AmbientClientConfig, ListOptions, RequestOptions } from './base';
import { ambientFetch, buildQueryString } from './base';
import type { Session, SessionList, SessionCreateRequest, SessionPatchRequest, SessionStatusPatchRequest } from './session';

export class SessionAPI {
  constructor(private readonly config: AmbientClientConfig) {}

  async create(data: SessionCreateRequest, opts?: RequestOptions): Promise<Session> {
    return ambientFetch<Session>(this.config, 'POST', '/sessions', data, opts);
  }

  async get(id: string, opts?: RequestOptions): Promise<Session> {
    return ambientFetch<Session>(this.config, 'GET', `/sessions/${id}`, undefined, opts);
  }

  async list(listOpts?: ListOptions, opts?: RequestOptions): Promise<SessionList> {
    const qs = buildQueryString(listOpts);
    return ambientFetch<SessionList>(this.config, 'GET', `/sessions${qs}`, undefined, opts);
  }
  async update(id: string, patch: SessionPatchRequest, opts?: RequestOptions): Promise<Session> {
    return ambientFetch<Session>(this.config, 'PATCH', `/sessions/${id}`, patch, opts);
  }

  async updateStatus(id: string, patch: SessionStatusPatchRequest, opts?: RequestOptions): Promise<Session> {
    return ambientFetch<Session>(this.config, 'PATCH', `/sessions/${id}/status`, patch, opts);
  }

  async start(id: string, opts?: RequestOptions): Promise<Session> {
    return ambientFetch<Session>(this.config, 'POST', `/sessions/${id}/start`, undefined, opts);
  }

  async stop(id: string, opts?: RequestOptions): Promise<Session> {
    return ambientFetch<Session>(this.config, 'POST', `/sessions/${id}/stop`, undefined, opts);
  }

  async *listAll(size: number = 100, opts?: RequestOptions): AsyncGenerator<Session> {
    let page = 1;
    while (true) {
      const result = await this.list({ page, size }, opts);
      for (const item of result.items) {
        yield item;
      }
      if (page * size >= result.total) {
        break;
      }
      page++;
    }
  }
}
