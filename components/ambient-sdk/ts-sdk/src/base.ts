// Code generated by ambient-sdk-generator from openapi.yaml — DO NOT EDIT.
// Source: ../../ambient-api-server/openapi/openapi.yaml
// Spec SHA256: 47119590c5b99c8ae2cf4280c6cd43829ffd283a58c334f22ff8aedc01851068
// Generated: 2026-02-26T15:57:52Z

export type ObjectReference = {
  id: string;
  kind: string;
  href: string;
  created_at: string | null;
  updated_at: string | null;
};

export type ListMeta = {
  kind: string;
  page: number;
  size: number;
  total: number;
};

export type APIError = {
  id: string;
  kind: string;
  href: string;
  code: string;
  reason: string;
  operation_id: string;
  status_code: number;
};

export class AmbientAPIError extends Error {
  readonly statusCode: number;
  readonly code: string;
  readonly reason: string;
  readonly operationId: string;

  constructor(error: APIError) {
    super(`ambient API error ${error.status_code}: ${error.code} — ${error.reason}`);
    this.name = 'AmbientAPIError';
    this.statusCode = error.status_code;
    this.code = error.code;
    this.reason = error.reason;
    this.operationId = error.operation_id;
  }
}

export type ListOptions = {
  page?: number;
  size?: number;
  search?: string;
  orderBy?: string;
  fields?: string;
};

export function buildQueryString(opts?: ListOptions): string {
  if (!opts) return '';
  const params = new URLSearchParams();
  if (opts.page !== undefined) params.set('page', String(opts.page));
  if (opts.size !== undefined) params.set('size', String(Math.min(opts.size, 65500)));
  if (opts.search) params.set('search', opts.search);
  if (opts.orderBy) params.set('orderBy', opts.orderBy);
  if (opts.fields) params.set('fields', opts.fields);
  const qs = params.toString();
  return qs ? `?${qs}` : '';
}

export type RequestOptions = {
  signal?: AbortSignal;
};

export type AmbientClientConfig = {
  baseUrl: string;
  token: string;
  project: string;
};

export async function ambientFetch<T>(
  config: AmbientClientConfig,
  method: string,
  path: string,
  body?: unknown,
  requestOpts?: RequestOptions,
): Promise<T> {
  const url = `${config.baseUrl}/api/ambient-api-server/v1${path}`;
  const headers: Record<string, string> = {
    'Authorization': `Bearer ${config.token}`,
    'X-Ambient-Project': config.project,
  };
  if (body !== undefined) {
    headers['Content-Type'] = 'application/json';
  }

  const resp = await fetch(url, {
    method,
    headers,
    body: body !== undefined ? JSON.stringify(body) : undefined,
    signal: requestOpts?.signal,
  });

  if (!resp.ok) {
    let errorData: APIError;
    try {
      const jsonData = await resp.json();
      // Validate that this looks like an APIError response
      if (typeof jsonData === 'object' && jsonData !== null) {
        errorData = {
          id: typeof jsonData.id === 'string' ? jsonData.id : '',
          kind: typeof jsonData.kind === 'string' ? jsonData.kind : 'Error',
          href: typeof jsonData.href === 'string' ? jsonData.href : '',
          code: typeof jsonData.code === 'string' ? jsonData.code : 'unknown_error',
          reason: typeof jsonData.reason === 'string' ? jsonData.reason : `HTTP ${resp.status}: ${resp.statusText}`,
          operation_id: typeof jsonData.operation_id === 'string' ? jsonData.operation_id : '',
          status_code: resp.status,
        };
      } else {
        throw new Error('Invalid error response format');
      }
    } catch {
      errorData = {
        id: '',
        kind: 'Error',
        href: '',
        code: 'unknown_error',
        reason: `HTTP ${resp.status}: ${resp.statusText}`,
        operation_id: '',
        status_code: resp.status,
      };
    }
    throw new AmbientAPIError(errorData);
  }

  if (resp.status === 204) {
    return undefined as T;
  }

  // Parse JSON response with validation
  const jsonData = await resp.json();
  // Note: In a production system, you might want to add runtime type validation here
  // For now, we trust the API contract but avoid the unsafe 'as Promise<T>' cast
  return jsonData;
}
