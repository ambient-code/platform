# Code generated by ambient-sdk-generator from openapi.yaml â€” DO NOT EDIT.
# Source: ../../ambient-api-server/openapi/openapi.yaml
# Spec SHA256: f0ec84178602f3437cc365a1e354b5286dbd72ff5c138db499664f62b927bb61
# Generated: 2026-02-28T15:30:52Z

from __future__ import annotations

from typing import Any, Iterator, Optional, TYPE_CHECKING

from ._base import ListOptions
from .session import Session, SessionList, SessionStatusPatch

if TYPE_CHECKING:
    from .client import AmbientClient


class SessionAPI:
    def __init__(self, client: AmbientClient) -> None:
        self._client = client

    def create(self, data: dict) -> Session:
        resp = self._client._request("POST", "/sessions", json=data)
        return Session.from_dict(resp)

    def get(self, resource_id: str) -> Session:
        resp = self._client._request("GET", f"/sessions/{resource_id}")
        return Session.from_dict(resp)

    def list(self, opts: Optional[ListOptions] = None) -> SessionList:
        params = opts.to_params() if opts else None
        resp = self._client._request("GET", "/sessions", params=params)
        return SessionList.from_dict(resp)
    def update(self, resource_id: str, patch: Any) -> Session:
        data = patch.to_dict() if hasattr(patch, "to_dict") else patch
        resp = self._client._request("PATCH", f"/sessions/{resource_id}", json=data)
        return Session.from_dict(resp)

    def update_status(self, resource_id: str, patch: Any) -> Session:
        data = patch.to_dict() if hasattr(patch, "to_dict") else patch
        resp = self._client._request("PATCH", f"/sessions/{resource_id}/status", json=data)
        return Session.from_dict(resp)

    def start(self, resource_id: str) -> Session:
        resp = self._client._request("POST", f"/sessions/{resource_id}/start")
        return Session.from_dict(resp)

    def stop(self, resource_id: str) -> Session:
        resp = self._client._request("POST", f"/sessions/{resource_id}/stop")
        return Session.from_dict(resp)

    def list_all(self, size: int = 100, **kwargs: Any) -> Iterator[Session]:
        page = 1
        while True:
            result = self.list(ListOptions().page(page).size(size))
            yield from result.items
            if page * size >= result.total:
                break
            page += 1
