# Code generated by ambient-sdk-generator from openapi.yaml â€” DO NOT EDIT.
# Source: {{.Header.SpecPath}}
# Spec SHA256: {{.Header.SpecHash}}
# Generated: {{.Header.Timestamp}}

from __future__ import annotations

from dataclasses import dataclass
from datetime import datetime
from typing import Any, Optional

from ._base import ListMeta, _parse_datetime


@dataclass(frozen=True)
class {{.Resource.Name}}:
    id: str = ""
    kind: str = ""
    href: str = ""
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None
{{- range .Resource.Fields}}
    {{.PythonName}}: {{.PythonType}} = {{pythonDefault .}}
{{- end}}

    @classmethod
    def from_dict(cls, data: dict) -> {{.Resource.Name}}:
        return cls(
            id=data.get("id", ""),
            kind=data.get("kind", ""),
            href=data.get("href", ""),
            created_at=_parse_datetime(data.get("created_at")),
            updated_at=_parse_datetime(data.get("updated_at")),
{{- range .Resource.Fields}}
{{- if isDateTime .}}
            {{.PythonName}}=_parse_datetime(data.get("{{.Name}}")),
{{- else if eq .PythonType "int"}}
            {{.PythonName}}=data.get("{{.Name}}", 0),
{{- else if eq .PythonType "float"}}
            {{.PythonName}}=data.get("{{.Name}}", 0.0),
{{- else if eq .PythonType "bool"}}
            {{.PythonName}}=data.get("{{.Name}}", False),
{{- else}}
            {{.PythonName}}=data.get("{{.Name}}", ""),
{{- end}}
{{- end}}
        )

    @classmethod
    def builder(cls) -> {{.Resource.Name}}Builder:
        return {{.Resource.Name}}Builder()


@dataclass(frozen=True)
class {{.Resource.Name}}List:
    kind: str = ""
    page: int = 0
    size: int = 0
    total: int = 0
    items: list[{{.Resource.Name}}] = ()

    @classmethod
    def from_dict(cls, data: dict) -> {{.Resource.Name}}List:
        return cls(
            kind=data.get("kind", ""),
            page=data.get("page", 0),
            size=data.get("size", 0),
            total=data.get("total", 0),
            items=[{{.Resource.Name}}.from_dict(item) for item in data.get("items", [])],
        )


class {{.Resource.Name}}Builder:
    def __init__(self) -> None:
        self._data: dict[str, Any] = {}

{{range .Resource.Fields}}{{if isWritable .}}
    def {{.PythonName}}(self, value: {{.PythonType}}) -> {{$.Resource.Name}}Builder:
        self._data["{{.Name}}"] = value
        return self
{{end}}{{end}}
    def build(self) -> dict:
{{- range .Resource.Fields}}
{{- if .Required}}
{{- if eq .PythonType "str"}}
        if "{{.Name}}" not in self._data:
            raise ValueError("{{.Name}} is required")
{{- end}}
{{- end}}
{{- end}}
        return dict(self._data)


class {{.Resource.Name}}Patch:
    def __init__(self) -> None:
        self._data: dict[str, Any] = {}

{{range .Resource.PatchFields}}
    def {{.PythonName}}(self, value: {{.PythonType}}) -> {{$.Resource.Name}}Patch:
        self._data["{{.Name}}"] = value
        return self
{{end}}
    def to_dict(self) -> dict:
        return dict(self._data)
{{if .Resource.HasStatusPatch}}

class {{.Resource.Name}}StatusPatch:
    def __init__(self) -> None:
        self._data: dict[str, Any] = {}

{{range .Resource.StatusPatchFields}}
    def {{.PythonName}}(self, value: {{.PythonType}}) -> {{$.Resource.Name}}StatusPatch:
        self._data["{{.Name}}"] = value
        return self
{{end}}
    def to_dict(self) -> dict:
        return dict(self._data)
{{end}}
