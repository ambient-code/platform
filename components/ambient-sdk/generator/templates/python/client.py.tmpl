# Code generated by ambient-sdk-generator from openapi.yaml â€” DO NOT EDIT.
# Source: {{.Header.SpecPath}}
# Spec SHA256: {{.Header.SpecHash}}
# Generated: {{.Header.Timestamp}}

from __future__ import annotations

from typing import Any, Iterator, Optional, TYPE_CHECKING

from ._base import ListOptions
from .{{.Resource.Name | snakeCase}} import {{.Resource.Name}}, {{.Resource.Name}}List{{if .Resource.HasStatusPatch}}, {{.Resource.Name}}StatusPatch{{end}}

if TYPE_CHECKING:
    from .client import AmbientClient


class {{.Resource.Name}}API:
    def __init__(self, client: AmbientClient) -> None:
        self._client = client

    def create(self, data: dict) -> {{.Resource.Name}}:
        resp = self._client._request("POST", "/{{.Resource.PathSegment}}", json=data)
        return {{.Resource.Name}}.from_dict(resp)

    def get(self, resource_id: str) -> {{.Resource.Name}}:
        resp = self._client._request("GET", f"/{{.Resource.PathSegment}}/{resource_id}")
        return {{.Resource.Name}}.from_dict(resp)

    def list(self, opts: Optional[ListOptions] = None) -> {{.Resource.Name}}List:
        params = opts.to_params() if opts else None
        resp = self._client._request("GET", "/{{.Resource.PathSegment}}", params=params)
        return {{.Resource.Name}}List.from_dict(resp)

{{- if .Resource.HasPatch}}
    def update(self, resource_id: str, patch: Any) -> {{.Resource.Name}}:
        data = patch.to_dict() if hasattr(patch, "to_dict") else patch
        resp = self._client._request("PATCH", f"/{{.Resource.PathSegment}}/{resource_id}", json=data)
        return {{.Resource.Name}}.from_dict(resp)
{{end}}
{{- if .Resource.HasDelete}}
    def delete(self, resource_id: str) -> None:
        self._client._request("DELETE", f"/{{.Resource.PathSegment}}/{resource_id}", expect_json=False)
{{end}}
{{- if .Resource.HasStatusPatch}}
    def update_status(self, resource_id: str, patch: Any) -> {{.Resource.Name}}:
        data = patch.to_dict() if hasattr(patch, "to_dict") else patch
        resp = self._client._request("PATCH", f"/{{.Resource.PathSegment}}/{resource_id}/status", json=data)
        return {{.Resource.Name}}.from_dict(resp)
{{end}}
{{- range .Resource.Actions}}
    def {{.}}(self, resource_id: str) -> {{$.Resource.Name}}:
        resp = self._client._request("POST", f"/{{$.Resource.PathSegment}}/{resource_id}/{{.}}")
        return {{$.Resource.Name}}.from_dict(resp)
{{end}}
    def list_all(self, size: int = 100, **kwargs: Any) -> Iterator[{{.Resource.Name}}]:
        page = 1
        while True:
            result = self.list(ListOptions().page(page).size(size))
            yield from result.items
            if page * size >= result.total:
                break
            page += 1
