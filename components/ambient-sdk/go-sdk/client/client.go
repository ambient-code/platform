// Code generated by ambient-sdk-generator from openapi.yaml â€” DO NOT EDIT.
// Source: /home/mturansk/projects/src/github.com/ambient/platform/components/ambient-api-server/openapi/openapi.yaml
// Spec SHA256: 27ef174cf2467464266e7bfc9d0aa30984a2ad917d93fdaded13f563c44af739
// Generated: 2026-02-24T20:49:14Z

package client

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"log/slog"
	"net/http"
	"net/url"
	"os"
	"regexp"
	"strings"
	"time"

	"github.com/ambient-code/platform/components/ambient-sdk/go-sdk/types"
)

type Client struct {
	httpClient  *http.Client
	baseURL     string
	token       string
	project     string
	logger      *slog.Logger
	userAgent   string
}

type ClientOption func(*Client)

func WithTimeout(timeout time.Duration) ClientOption {
	return func(c *Client) {
		c.httpClient.Timeout = timeout
	}
}

func WithLogger(logger *slog.Logger) ClientOption {
	return func(c *Client) {
		c.logger = logger
	}
}

func WithUserAgent(userAgent string) ClientOption {
	return func(c *Client) {
		c.userAgent = userAgent
	}
}

func NewClient(baseURL, token, project string, opts ...ClientOption) (*Client, error) {
	if token == "" {
		return nil, fmt.Errorf("token is required")
	}

	if project == "" {
		return nil, fmt.Errorf("project is required")
	}

	if err := validateURL(baseURL); err != nil {
		return nil, fmt.Errorf("invalid base URL: %w", err)
	}

	c := &Client{
		httpClient: &http.Client{
			Timeout: 30 * time.Second,
		},
		baseURL:   strings.TrimSuffix(baseURL, "/"),
		token:     token,
		project:   project,
		logger:    slog.Default(),
		userAgent: "ambient-go-sdk/1.0.0",
	}

	for _, opt := range opts {
		opt(c)
	}

	c.logger = c.logger.With(slog.String("sdk", "go"), slog.String("project", project))

	return c, nil
}

func NewClientFromEnv(opts ...ClientOption) (*Client, error) {
	baseURL := os.Getenv("AMBIENT_API_URL")
	if baseURL == "" {
		baseURL = "http://localhost:8000"
	}

	token := os.Getenv("AMBIENT_TOKEN")
	if token == "" {
		return nil, fmt.Errorf("AMBIENT_TOKEN environment variable is required")
	}

	project := os.Getenv("AMBIENT_PROJECT")
	if project == "" {
		project = os.Getenv("ANTHROPIC_VERTEX_PROJECT_ID")
	}
	if project == "" {
		return nil, fmt.Errorf("AMBIENT_PROJECT or ANTHROPIC_VERTEX_PROJECT_ID environment variable is required")
	}

	return NewClient(baseURL, token, project, opts...)
}

func (c *Client) do(ctx context.Context, method, path string, body []byte, expectedStatus int, result interface{}) error {
	url := c.baseURL + "/api/ambient-api-server/v1" + path
	
	req, err := http.NewRequestWithContext(ctx, method, url, nil)
	if err != nil {
		return fmt.Errorf("create request: %w", err)
	}

	if body != nil {
		req.Body = io.NopCloser(strings.NewReader(string(body)))
		req.Header.Set("Content-Type", "application/json")
	}

	req.Header.Set("Authorization", "Bearer "+c.token)
	req.Header.Set("X-Ambient-Project", c.project)
	req.Header.Set("User-Agent", c.userAgent)
	req.Header.Set("Accept", "application/json")

	c.logger.Debug("HTTP request",
		slog.String("method", method),
		slog.String("url", sanitizeLogURL(url)),
		slog.Int("body_len", len(body)),
	)

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return fmt.Errorf("HTTP request failed: %w", err)
	}
	defer resp.Body.Close()

	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("read response body: %w", err)
	}

	c.logger.Debug("HTTP response",
		slog.Int("status", resp.StatusCode),
		slog.Int("body_len", len(respBody)),
	)

	if resp.StatusCode != expectedStatus {
		var apiErr types.APIError
		if json.Unmarshal(respBody, &apiErr) == nil && apiErr.Code != "" {
			apiErr.StatusCode = resp.StatusCode
			return &apiErr
		}
		return &types.APIError{
			StatusCode: resp.StatusCode,
			Code:       "http_error",
			Reason:     fmt.Sprintf("HTTP %d: unexpected status", resp.StatusCode),
		}
	}

	if result != nil && len(respBody) > 0 {
		if err := json.Unmarshal(respBody, result); err != nil {
			return fmt.Errorf("unmarshal response: %w", err)
		}
	}

	return nil
}

func (c *Client) doWithQuery(ctx context.Context, method, path string, body []byte, expectedStatus int, result interface{}, opts *types.ListOptions) error {
	queryPath := path
	if opts != nil {
		params := url.Values{}
		if opts.Page > 0 {
			params.Set("page", fmt.Sprintf("%d", opts.Page))
		}
		if opts.Size > 0 {
			params.Set("size", fmt.Sprintf("%d", opts.Size))
		}
		if opts.Search != "" {
			params.Set("search", opts.Search)
		}
		if len(params) > 0 {
			queryPath += "?" + params.Encode()
		}
	}
	
	return c.do(ctx, method, queryPath, body, expectedStatus, result)
}

func validateURL(rawURL string) error {
	if rawURL == "" {
		return fmt.Errorf("URL cannot be empty")
	}

	if strings.Contains(rawURL, "example.com") || strings.Contains(rawURL, "placeholder") {
		return fmt.Errorf("placeholder URLs are not allowed")
	}

	u, err := url.Parse(rawURL)
	if err != nil {
		return fmt.Errorf("invalid URL format: %w", err)
	}

	if u.Scheme != "http" && u.Scheme != "https" {
		return fmt.Errorf("only HTTP and HTTPS schemes are supported")
	}

	return nil
}

func sanitizeLogURL(rawURL string) string {
	tokenPattern := regexp.MustCompile(`([Bb]earer\s+)[a-zA-Z0-9\-_~.+/=]+`)
	return tokenPattern.ReplaceAllString(rawURL, "${1}[REDACTED]")
}